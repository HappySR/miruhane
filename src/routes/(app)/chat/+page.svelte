<script lang="ts">
  import { onMount } from "svelte";
  import { writable, get } from "svelte/store";
  import AppSidebar from "$lib/components/app-sidebar.svelte";
  import * as Breadcrumb from "$lib/components/ui/breadcrumb/index.js";
  import { Separator } from "$lib/components/ui/separator/index.js";
  import * as Sidebar from "$lib/components/ui/sidebar/index.js";
  import { Mic, MicOff, Send } from "lucide-svelte";

  // Define writable stores with proper types
  const isSpeaking = writable<boolean>(false);
  const isRecording = writable<boolean>(false);
  const showSubtitles = writable<boolean>(true);
  const scale = writable<number>(1);
  const textToSpeak = writable<string>("Awaiting your input...");
  const userInput = writable<string>(""); // Stores user input (recorded or typed)
  const isLoading = writable<boolean>(false);

  // Define types for variables
  let speechRecognition: Window["SpeechRecognition"] | null = null;
  let shouldContinueRecording = false;

  const startRecording = (): void => {
    if (speechRecognition && !get(isRecording)) {
      console.log("Starting recording...");
      isRecording.set(true);
      shouldContinueRecording = true;
      userInput.set(""); // Clear any previous input
      speechRecognition.start();
    }
  };

  const stopRecording = (): void => {
    if (speechRecognition && get(isRecording)) {
      console.log("Stopping recording...");
      isRecording.set(false);
      shouldContinueRecording = false;
      speechRecognition.stop();
    }
  };

  onMount(() => {
    if ("SpeechRecognition" in window || "webkitSpeechRecognition" in window) {
      speechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      speechRecognition.lang = "en-US";
      speechRecognition.interimResults = true;

      speechRecognition.onresult = (event: SpeechRecognitionEvent): void => {
        let transcript = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          transcript += event.results[i][0].transcript;
        }

        if (event.results[event.resultIndex].isFinal) {
          console.log("Final recognized speech:", transcript.trim());
          // Concatenate the final transcript with the previous input
          userInput.update((prevInput) => prevInput + " " + transcript.trim());
        }
      };

      speechRecognition.onerror = (event: SpeechRecognitionErrorEvent): void => {
        console.error("SpeechRecognition error:", event.error);
        stopRecording();
      };

      speechRecognition.onend = (): void => {
        console.log("SpeechRecognition ended.");
        if (shouldContinueRecording) {
          console.log("Restarting recording...");
          speechRecognition?.start();
        }
      };

      console.log("SpeechRecognition initialized.");
    } else {
      console.error("SpeechRecognition is not supported in this browser.");
      textToSpeak.set("Your browser does not support SpeechRecognition.");
    }
  });

  const handleSubmit = async (): Promise<void> => {
    const query = get(userInput).trim();
    if (query) {
      console.log("Query sent to Gemini AI:", query);
      const answer = await getGeminiAnswer(query);
      textToSpeak.set(answer);
      if (get(showSubtitles)) {
        speak(answer);
      }
    }
  };

  const getGeminiAnswer = async (query: string): Promise<string> => {
    const apiKey = "Your_Gemini_API_Key"; // Replace with your actual API key
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;

    const requestBody = {
      contents: [
        {
          parts: [{ text: query }],
        },
      ],
    };

    try {
      isLoading.set(true); // Indicate loading state

      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(requestBody), // Send the request payload
      });

      if (!response.ok) {
        console.error("Error response from Gemini API:", response.statusText);
        return `Error: ${response.statusText}`;
      }

      const data = await response.json();
      isLoading.set(false); // Turn off loading state

      // Log the raw API response for debugging
      console.log("Raw API Response:", data);

      // Safely extract and return the generated content
      if (data?.candidates?.length > 0 && data.candidates[0]?.content?.parts?.[0]?.text) {
        return data.candidates[0].content.parts[0].text; // Return the text generated by Gemini
      } else {
        return "No valid content found in the response.";
      }
    } catch (error) {
      console.error("Error fetching from Gemini API:", error);
      isLoading.set(false); // Turn off loading state
      return "There was an error processing your request. Please try again.";
    }
  };

  const speak = (text: string): void => {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.onstart = (): void => {
      isSpeaking.set(true);
      scale.set(1.2);
    };
    utterance.onend = (): void => {
      isSpeaking.set(false);
      scale.set(1);
    };
    speechSynthesis.speak(utterance);
  };
</script>

<Sidebar.Provider>
  <AppSidebar />
  <Sidebar.Inset>
    <header class="header">
      <div class="header-content">
        <Sidebar.Trigger class="sidebar-trigger" />
        <Separator orientation="vertical" class="separator" />
        <Breadcrumb.Root>
          <Breadcrumb.List>
            <Breadcrumb.Item>
              <Breadcrumb.Link href="#" class="breadcrumb-link">AI Dashboard</Breadcrumb.Link>
            </Breadcrumb.Item>
            <Breadcrumb.Separator />
            <Breadcrumb.Item>
              <Breadcrumb.Page>Visualizer</Breadcrumb.Page>
            </Breadcrumb.Item>
          </Breadcrumb.List>
        </Breadcrumb.Root>
      </div>
    </header>

    <main class="main-container">
      <!-- Visualizer Section -->
      <div class="visualizer-container">
        <div class="outer-ring">
          <div class="inner-ring">
            <div class="pulse"></div>
          </div>
        </div>
      </div>

      <!-- Input Section -->
      <div class="input-section">
        <button
          onclick={$isRecording ? stopRecording : startRecording}
          class="record-button"
          style="background-color: {$isRecording ? '#ff4d4d' : '#4CAF50'};"
        >
          {#if $isRecording}
            <MicOff class="icon" />
          {:else}
            <Mic class="icon" />
          {/if}
        </button>
        <input
          type="text"
          class="query-input"
          placeholder="Type your query..."
          bind:value={$userInput}
        />
        <button onclick={handleSubmit} class="send-button" disabled={$isRecording}>
          <Send class="icon" /> Send
        </button>
      </div>

      <!-- Subtitles -->
      {#if $showSubtitles}
        <div class="subtitles">
          <p>{$isLoading ? "Processing..." : $textToSpeak}</p>
        </div>
      {/if}
    </main>
  </Sidebar.Inset>
</Sidebar.Provider>

<style>
  /* General Reset */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', sans-serif;
    background: linear-gradient(to bottom, #0f172a, #1e293b);
    color: #e2e8f0;
    height: 100vh;
    overflow: hidden;
  }

  /* Header */
  .header {
    height: 70px;
    background: #1e293b;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
  }

  .header-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 90%;
    max-width: 1200px;
  }

  .breadcrumb-link {
    color: #a5b4fc;
    text-decoration: none;
    font-weight: 600;
    transition: color 0.3s ease;
  }

  .breadcrumb-link:hover {
    color: #818cf8;
  }

  /* Main Container */
  .main-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    height: calc(100vh - 70px);
    padding: 20px;
    text-align: center;
  }

  /* Visualizer */
  .visualizer-container {
    position: relative;
    width: 300px;
    height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .outer-ring {
    width: 300px;
    height: 300px;
    border-radius: 50%;
    background: conic-gradient(#4caf50, #4f46e5, #1e40af, #4caf50);
    animation: rotate 4s linear infinite;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 0 30px rgba(79, 70, 229, 0.6);
  }

  @keyframes rotate {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  .inner-ring {
    width: 250px;
    height: 250px;
    border-radius: 50%;
    background: radial-gradient(circle, #1e293b, #0f172a);
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
  }

  .pulse {
    width: 100px;
    height: 100px;
    background: radial-gradient(circle, #ffffff, #818cf8);
    border-radius: 50%;
    animation: pulse 2s infinite;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
  }

  @keyframes pulse {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
  }

  /* Input Section */
  .input-section {
    display: flex;
    gap: 15px;
    width: 100%;
    max-width: 600px;
  }

  .record-button {
    width: 50px;
    height: 50px;
    border: none;
    border-radius: 50%;
    color: #fff;
    font-size: 1.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .record-button:hover {
    transform: scale(1.1);
    box-shadow: 0px 6px 15px rgba(0, 0, 0, 0.3);
  }

  .query-input {
    flex: 1;
    padding: 12px;
    border-radius: 8px;
    border: 1px solid #334155;
    background: #1e293b;
    color: #e2e8f0;
    font-size: 1rem;
    box-shadow: inset 0px 2px 4px rgba(0, 0, 0, 0.1);
    transition: border 0.3s ease, box-shadow 0.3s ease;
  }

  .query-input:focus {
    border-color: #4caf50;
    box-shadow: 0px 0px 10px rgba(79, 70, 229, 0.6);
    outline: none;
  }

  .send-button {
    padding: 12px 20px;
    background-color: #4caf50;
    color: white;
    font-size: 1rem;
    border: none;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.3s ease, transform 0.3s ease;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
  }

  .send-button:hover {
    background-color: #45a049;
    transform: scale(1.05);
  }

  .icon {
    font-size: 1.5rem;
  }

  /* Subtitles */
  .subtitles {
    margin-top: 20px;
    font-size: 1.2rem;
    font-style: italic;
    color: #9ca3af;
  }
</style>
